{"version":3,"names":[],"mappings":"","sources":["tabulate.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function () {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function () {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function () {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function () {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function () {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _version.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n},{\"./nil.js\":3,\"./parse.js\":4,\"./stringify.js\":8,\"./v1.js\":9,\"./v3.js\":10,\"./v4.js\":12,\"./v5.js\":13,\"./validate.js\":14,\"./version.js\":15}],2:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  const output = [];\n  const length32 = input.length * 32;\n  const hexTab = '0123456789abcdef';\n\n  for (let i = 0; i < length32; i += 8) {\n    const x = input[i >> 5] >>> i % 32 & 0xff;\n    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (let i = 0; i < x.length; i += 16) {\n    const olda = a;\n    const oldb = b;\n    const oldc = c;\n    const oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  const length8 = input.length * 8;\n  const output = new Uint32Array(getOutputLength(length8));\n\n  for (let i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nvar _default = md5;\nexports.default = _default;\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;\n},{}],4:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;\n},{\"./validate.js\":14}],5:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;\n},{}],6:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\n\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n},{}],7:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nvar _default = sha1;\nexports.default = _default;\n},{}],8:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;\n},{\"./validate.js\":14}],9:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.default)(b);\n}\n\nvar _default = v1;\nexports.default = _default;\n},{\"./rng.js\":6,\"./stringify.js\":8}],10:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;\n},{\"./md5.js\":2,\"./v35.js\":11}],11:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.default)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}\n},{\"./parse.js\":4,\"./stringify.js\":8}],12:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.default)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;\n},{\"./rng.js\":6,\"./stringify.js\":8}],13:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;\n},{\"./sha1.js\":7,\"./v35.js\":11}],14:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;\n},{\"./regex.js\":5}],15:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nvar _default = version;\nexports.default = _default;\n},{\"./validate.js\":14}],16:[function(require,module,exports){\n\"use strict\";\n\nvar _controllersModule = require(\"./controllers/_controllersModule\");\n\nvar _resourcesModule = require(\"./resources/_resourcesModule\");\n\nvar name = 'tabulate';\nangular.module(name, [_controllersModule.ControllersModule, _resourcesModule.ResourcesModule]);\nangular.module('umbraco').requires.push(name);\n\n},{\"./controllers/_controllersModule\":17,\"./resources/_resourcesModule\":22}],17:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ControllersModule = void 0;\n\nvar _tabulate = require(\"./tabulate.controller\");\n\nvar _tabulateDialog = require(\"./tabulate.dialog.controller\");\n\nvar _tabulateMapdialog = require(\"./tabulate.mapdialog.controller\");\n\nvar _tabulateSettings = require(\"./tabulate.settings.controller\");\n\nvar ControllersModule = angular.module('tabulate.controllers', []).controller(_tabulate.TabulateController.name, _tabulate.TabulateController).controller(_tabulateDialog.TabulateDialogController.name, _tabulateDialog.TabulateDialogController).controller(_tabulateMapdialog.TabulateMapDialogController.name, _tabulateMapdialog.TabulateMapDialogController).controller(_tabulateSettings.TabulateSettingsController.name, _tabulateSettings.TabulateSettingsController).name;\nexports.ControllersModule = ControllersModule;\n\n},{\"./tabulate.controller\":18,\"./tabulate.dialog.controller\":19,\"./tabulate.mapdialog.controller\":20,\"./tabulate.settings.controller\":21}],18:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TabulateController = void 0;\n\nvar _uuid = require(\"uuid\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TabulateController = function TabulateController($scope, $q, $filter, editorState, authResource, notificationsService, editorService, overlayService, tabulateResource, tabulatePagingService) {\n  var _this = this;\n\n  _classCallCheck(this, TabulateController);\n\n  _defineProperty(this, \"updateUmbracoModel\", function () {\n    _this.$scope.model.value.data = _this.data;\n    _this.$scope.model.value.settings = _this.settings;\n  });\n\n  _defineProperty(this, \"emptyModel\", function () {\n    var newModel = {\n      _guid: (0, _uuid.v4)()\n    };\n\n    _this.settings.columns.forEach(function (c) {\n      newModel[c.displayName] = '';\n    });\n\n    return newModel;\n  });\n\n  _defineProperty(this, \"clearModel\", function () {\n    _this.overlayService.confirmDelete({\n      confirmMessage: 'Do you really want to delete all data?',\n      hideHeader: true,\n      submit: function submit() {\n        _this.data = [];\n        _this.settings = [];\n        _this.pagination = {\n          items: [],\n          currentPage: 1,\n          search: '',\n          pageNumber: 1,\n          pageIndex: 0\n        };\n        _this.$scope.model.value = [];\n\n        _this.init();\n\n        _this.overlayService.close();\n      },\n      close: function close() {\n        return _this.overlayService.close();\n      }\n    });\n  });\n\n  _defineProperty(this, \"setSorting\", function () {\n    _this.manualSort = false;\n\n    if (!_this.settings.sortOrder) {\n      _this.settings.sortOrder = 'A';\n    } else if (_this.settings.sortOrder === 'M') {\n      _this.settings.numPerPage = _this.data.length;\n      _this.manualSort = true;\n    } else {\n      _this.data = _this.$filter('orderBy')(_this.data, '_label', _this.settings.sortOrder === 'D');\n    }\n\n    _this.updateUmbracoModel();\n  });\n\n  _defineProperty(this, \"removeColumn\", function (col) {\n    // if this is the last column, get confirmation first, then remove the column and model data\n    // otherwise, remove the column if multiple remain\n    if (_this.settings.columns.length === 1) {\n      _this.overlayService.confirm({\n        confirmMessage: 'Removing all columns will also delete all stored data. Continue?',\n        hideHeader: true,\n        submit: function submit() {\n          _this.settings = {\n            columns: [],\n            label: '',\n            isListView: false,\n            numPerPage: 10\n          };\n          _this.data = [];\n\n          _this.setPaging();\n\n          _this.noConfig = true;\n\n          _this.overlayService.close();\n        },\n        close: function close() {\n          return _this.overlayService.close();\n        }\n      });\n    } else if (_this.settings.columns.length > 1) {\n      var dataLabel = _this.settings.columns[col].displayName;\n\n      _this.data.forEach(function (item) {\n        if (item.hasOwnProperty(dataLabel)) {\n          delete item[dataLabel];\n        }\n      });\n\n      _this.settings.columns.splice(col, 1);\n    }\n\n    _this.updateUmbracoModel();\n  });\n\n  _defineProperty(this, \"updateColumns\", function (changes) {\n    // each change has a new and old value - only continue if new exists ie has been changed\n    // i = counter for the outer loop\n    // c = changes object for the loop iteration\n    // j = counter for the inner loop\n    // d = the data object for the inner loop iteration\n    var i, c, j, d;\n\n    for (i = 0; i < changes.length; i += 1) {\n      c = changes[i];\n\n      if (c.newName !== undefined) {\n        // check each value for old name, if it exists update to new\n        for (j = 0; j < _this.data.length; j += 1) {\n          d = _this.data[j]; // has a renamed column, needs updating\n\n          if (d.hasOwnProperty(c.old)) {\n            // add a new property using the old value, then delete the old property\n            // only if the name has changed\n            if (c.newName !== c.old) {\n              d[c.newName] = d[c.old];\n              delete d[c.old];\n            } // update the type, only if it has changed\n\n\n            if (d.type !== c.newType) {\n              d.type = c.newType;\n            }\n          }\n        }\n      }\n    }\n  });\n\n  _defineProperty(this, \"getOverlayBase\", function (title, type) {\n    return {\n      view: _this.dialogPath,\n      title: title,\n      type: type,\n      size: _this.viewSize,\n      config: _this.settings,\n      rteConfig: _this.rteConfig\n    };\n  });\n\n  _defineProperty(this, \"addRow\", function () {\n    var addOverlay = _objectSpread(_objectSpread({}, _this.getOverlayBase('Add row', 'add')), {}, {\n      data: _this.emptyModel(),\n      submit: function submit(result) {\n        _this.setRteFields(result); // geocode the model and add it to the model\n\n\n        var newItem = _this.mapsLoaded ? _this.tabulateResource.geocode(result.data) : result.data;\n\n        _this.tabulateResource.setLabels(newItem, true, _this.settings.label);\n\n        _this.data.push(newItem);\n\n        _this.afterAddEditRow();\n      },\n      close: function close() {\n        return _this.editorService.close();\n      }\n    });\n\n    _this.editorService.open(addOverlay);\n  });\n\n  _defineProperty(this, \"editRow\", function (guid) {\n    var idx = _this.data.findIndex(function (d) {\n      return d._guid === guid;\n    });\n\n    var originalValue = _objectSpread({}, _this.data[idx]);\n\n    var editOverlay = _objectSpread(_objectSpread({}, _this.getOverlayBase('Edit row', 'edit')), {}, {\n      data: _this.data[idx],\n      submit: function submit(model) {\n        _this.setRteFields(model);\n\n        var item = model.data; // if the model has a new address, geocode it\n        // then store the model in the model\n\n        _this.tabulateResource.setLabels(item, true, _this.settings.label);\n\n        model.recode && _this.mapsLoaded ? _this.tabulateResource.geocode(item) : {}; // send new, old and mappings\n\n        _this.tabulateResource.updateMappedEditor(item, originalValue, _this.settings.mappings, _this.$scope.model.alias, _this.getCurrentVariant());\n\n        _this.afterAddEditRow();\n      },\n      close: function close() {\n        return _this.editorService.close();\n      }\n    });\n\n    _this.editorService.open(editOverlay);\n  });\n\n  _defineProperty(this, \"afterAddEditRow\", function () {\n    _this.editorService.close();\n\n    _this.updateUmbracoModel();\n\n    _this.setSorting();\n\n    _this.setPaging();\n  });\n\n  _defineProperty(this, \"getCurrentVariant\", function () {\n    return _this.editorState.current.variants.find(function (v) {\n      return v.active;\n    });\n  });\n\n  _defineProperty(this, \"removeRow\", function (guid) {\n    var idx = _this.data.findIndex(function (d) {\n      return d._guid === guid;\n    });\n\n    if (_this.data.length) {\n      _this.overlayService.confirm({\n        confirmMessage: 'Are you sure you want to remove this item?',\n        hideHeader: true,\n        submit: function submit() {\n          _this.data.splice(idx, 1);\n\n          _this.updateUmbracoModel();\n\n          _this.setPaging();\n\n          _this.overlayService.close();\n        },\n        close: function close() {\n          return _this.overlayService.close();\n        }\n      });\n    }\n  });\n\n  _defineProperty(this, \"disableRow\", function (guid) {\n    var row = _this.data.find(function (d) {\n      return d._guid === guid;\n    });\n\n    var previousValue = _objectSpread({}, row);\n\n    row.disabled = !!row.disabled ? false : true;\n\n    _this.tabulateResource.updateMappedEditor(row, previousValue, _this.settings.mappings, _this.$scope.model.alias, _this.getCurrentVariant());\n\n    _this.updateUmbracoModel();\n  });\n\n  _defineProperty(this, \"setRteFields\", function (model) {\n    // get the value from rte fields, if any exist\n    if (!model.rteConfig) return;\n    var rteKeys = Object.keys(model.rteConfig);\n\n    if (rteKeys.length) {\n      var _iterator = _createForOfIteratorHelper(rteKeys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          model.data[key] = model.rteConfig[key].value;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  });\n\n  _defineProperty(this, \"openSettings\", function () {\n    _this.search = '';\n    var settingsOverlay = {\n      view: \"\".concat(_this.basePath, \"/overlays/settings.html\"),\n      title: 'Settings',\n      size: 'medium',\n      alias: _this.$scope.model.alias,\n      data: _this.data,\n      config: _this.settings,\n      submit: function submit(model) {\n        _this.editorService.close();\n\n        _this.data = model.data;\n\n        _this.setSorting();\n\n        _this.setPaging(); // if the columnsToRemove array exists, remove each config row\n\n\n        if (model.columnsToRemove.length > 0) {\n          var _iterator2 = _createForOfIteratorHelper(model.columnsToRemove),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var col = _step2.value;\n              removeColumn(col);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        } // changes object will exist if changes were made to column names or types\n\n\n        var hasColumnChanges = model.changes.some(function (x) {\n          return x.hasOwnProperty('newName') || x.hasOwnProperty('newType');\n        });\n\n        if (hasColumnChanges) {\n          _this.updateColumns(model.changes);\n        } // if the config has been altered\n\n\n        if (hasColumnChanges || model.newColumnName || model.configChanged) {\n          _this.notificationsService.success('Settings updated', 'Don\\'t forget to save your changes');\n        } // better force the labels to be reset - not always apparent from checking config changes\n\n\n        _this.tabulateResource.setLabels(_this.data, true, _this.settings.label); // finally, if there's nothing left in the config, set the noConfig state\n\n\n        _this.noConfig = _this.settings === undefined ? true : false; // need to do this explicitly as it may be imported content\n\n        _this.updateUmbracoModel();\n      },\n      close: function close() {\n        return _this.editorService.close();\n      }\n    };\n\n    _this.editorService.open(settingsOverlay);\n  });\n\n  _defineProperty(this, \"goToPage\", function (pageNumber) {\n    _this.pagination.pageIndex = pageNumber - 1;\n    _this.pagination.pageNumber = pageNumber;\n\n    _this.setPaging();\n  });\n\n  _defineProperty(this, \"setPaging\", function () {\n    _this.pagination = _this.tabulatePagingService.updatePaging(_this.data, _this.pagination.search, _this.pagination.pageNumber, _this.settings.numPerPage);\n    _this.noResults = _this.pagination.items.length === 0 && _this.data.length ? true : false;\n  });\n\n  _defineProperty(this, \"setDataGuids\", function () {\n    if (_this.data[0]._guid) return;\n\n    _this.data.forEach(function (d) {\n      d._guid = (0, _uuid.v4)();\n    });\n\n    _this.notificationsService.info('Tabulate data updated - please save and reload');\n  });\n\n  _defineProperty(this, \"init\", function () {\n    if (_this.$scope.model.value === undefined || _this.$scope.model.value.length === 0) {\n      _this.$scope.model.value = {\n        settings: {\n          columns: [],\n          label: '',\n          islistView: false,\n          numPerPage: 10\n        },\n        data: []\n      };\n      _this.data = _this.$scope.model.value.data;\n      _this.settings = _this.$scope.model.value.settings;\n    } else if (_this.$scope.model.value.settings) {\n      _this.data = _this.$scope.model.value.data;\n      _this.settings = _this.$scope.model.value.settings;\n\n      if (_this.data) {\n        _this.setDataGuids();\n\n        _this.setSorting();\n\n        _this.setPaging();\n      }\n    }\n\n    _this.noConfig = _this.settings.columns.length === 0;\n    _this.loading = false;\n  });\n\n  this.$scope = $scope;\n  this.$filter = $filter;\n  this.editorState = editorState;\n  this.authResource = authResource;\n  this.notificationsService = notificationsService;\n  this.editorService = editorService;\n  this.overlayService = overlayService;\n  this.tabulateResource = tabulateResource;\n  this.tabulatePagingService = tabulatePagingService;\n  this.basePath = Umbraco.Sys.ServerVariables.umbracoSettings.appPluginsPath + '/Tabulate/Backoffice';\n  this.dialogPath = $scope.model.config.customView || \"\".concat(this.basePath, \"/overlays/dialog.html\");\n  this.viewSize = $scope.model.config.customView ? $scope.model.config.overlaySize : 'small'; // hide the umbraco label if the view is set to wide\n\n  this.$scope.model.hideLabel = $scope.model.config.wide == true;\n  this.rteConfig = $scope.model.config.rte; // these don't need to be scoped\n\n  this.data;\n  this.settings;\n  this.manualSort = false;\n  this.hideSettings = true;\n  this.pagination = {\n    items: [],\n    totalPages: 1,\n    search: '',\n    pageNumber: 1,\n    pageIndex: 0\n  };\n  this.sortOptions = {\n    axis: 'y',\n    cursor: 'move',\n    handle: '.sort-handle',\n    stop: function stop() {\n      _this.$scope.model.value.data = _this.data = _this.pagination.items;\n    }\n  };\n  var promises = [tabulateResource.loadGoogleMaps($scope.model.config.mapsApiKey), authResource.getCurrentUser()];\n  this.loading = true;\n  $q.all(promises).then(function (resp) {\n    _this.mapsLoaded = resp[0];\n    _this.hideSettings = false;\n\n    if ($scope.model.config.canAccessSettings) {\n      var canAccessSettings = $scope.model.config.canAccessSettings.split(',');\n      _this.hideSettings = !resp[1].userGroups.some(function (x) {\n        return canAccessSettings.includes(x);\n      });\n    }\n\n    _this.init();\n  });\n} // this is simply for convenience - update data/settings rather than $scope.model.value.data\n// need to remember though to call it whenever the data or settings objects are modified\n;\n\nexports.TabulateController = TabulateController;\n\n_defineProperty(TabulateController, \"name\", 'Tabulate.Controller');\n\n},{\"uuid\":1}],19:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TabulateDialogController = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TabulateDialogController = function TabulateDialogController($scope, editorService, editorState, tabulateResource, assetsService, $timeout) {\n  var _this = this;\n\n  _classCallCheck(this, TabulateDialogController);\n\n  _defineProperty(this, \"$onDestroy\", function () {\n    _this.addressWatch ? _this.addressWatch() : {};\n  });\n\n  _defineProperty(this, \"bindLinkedColumn\", function (column) {\n    var tabulateEditors = _this.tabulateResource.getTabulateEditors(_this.$scope.model.alias, _this.editorState.current.variants.find(function (v) {\n      return v.active;\n    }));\n\n    var linkedEditor = tabulateEditors.find(function (t) {\n      return t.alias == column.source;\n    });\n    var linkedTabulateEditor = linkedEditor.editor === 'NW.Tabulate'; // get the data from the linked editor, depending on alias\n\n    var data = linkedTabulateEditor ? linkedEditor.value.data : linkedEditor.value; // configure typeahead using linked data\n\n    var options = {\n      highlight: true,\n      minLength: 1\n    };\n    var sources = {\n      name: 'sources',\n      source: new Bloodhound({\n        datumTokenizer: linkedTabulateEditor ? Bloodhound.tokenizers.obj.whitespace('_label') : Bloodhound.tokenizers.whitespace,\n        queryTokenizer: Bloodhound.tokenizers.whitespace,\n        local: data\n      })\n    };\n\n    if (linkedTabulateEditor) {\n      sources.displayKey = '_label';\n    }\n\n    var typeaheadElement = angular.element('#typeahead_' + _this.safeName(column.displayName));\n    typeaheadElement.typeahead(options, sources).bind(\"typeahead:selected\", function (obj, datum, name) {\n      _this.$scope.model.data[column.displayName] = datum._label;\n      _this.$scope.model.data[column.displayName + '_link'] = datum._guid;\n    }).bind(\"typeahead:autocompleted\", function (obj, datum, name) {\n      _this.$scope.model.data[column.displayName] = datum._label;\n      _this.$scope.model.data[column.displayName + '_link'] = datum._guid;\n    });\n  });\n\n  _defineProperty(this, \"safeName\", function (str) {\n    return str.replace(/ /gi, '_');\n  });\n\n  _defineProperty(this, \"viewLocation\", function () {\n    var mapOverlay = {\n      view: Umbraco.Sys.ServerVariables.Tabulate.pluginPath + '/overlays/mapDialog.html',\n      lat: _this.$scope.model.data.lat,\n      lng: _this.$scope.model.data.lng,\n      title: 'Update address coordinates',\n      submit: function submit(resp) {\n        _this.editorService.close();\n\n        var keys = Object.keys(_this.$scope.model.data._Address);\n\n        if (keys.length === 2) {\n          _this.$scope.model.data._Address[keys[0]] = resp.lat;\n          _this.$scope.model.data._Address[keys[1]] = resp.lng;\n          _this.$scope.model.data.lat = resp.lat;\n          _this.$scope.model.data.lng = resp.lng;\n        }\n      },\n      close: function close() {\n        return _this.editorService.close();\n      }\n    };\n\n    _this.editorService.open(mapOverlay);\n  });\n\n  _defineProperty(this, \"getRteConfig\", function (n) {\n    return {\n      alias: n.toLowerCase(),\n      config: {\n        editor: _this.$scope.model.rteConfig,\n        hideLabel: true\n      },\n      culture: null,\n      description: '',\n      editor: 'Umbraco.TinyMCE',\n      hideLabel: true,\n      id: n.length,\n      isSensitive: false,\n      label: n,\n      readonly: false,\n      validation: {\n        mandatory: false,\n        pattern: null\n      },\n      value: _this.$scope.model.data[n],\n      view: 'views/propertyeditors/rte/rte.html'\n    };\n  });\n\n  this.$scope = $scope;\n  this.editorService = editorService;\n  this.editorState = editorState;\n  this.tabulateResource = tabulateResource;\n\n  this.inputType = function (type) {\n    return type === 'string' ? 'text' : type;\n  }; // view loops through the properties array to build the rte - o will have a value added if the data model contains rte fields\n\n\n  this.$scope.model.rteConfig = {};\n  var rteKeys = this.$scope.model.config.columns.filter(function (x) {\n    return x.type === 'rte';\n  }).map(function (x) {\n    return x.displayName;\n  });\n  rteKeys.forEach(function (displayName) {\n    return _this.$scope.model.rteConfig[displayName] = _this.getRteConfig(displayName);\n  }); // check for, and link, linked columns\n\n  var linkedColumns = this.$scope.model.config.columns.filter(function (x) {\n    return x.type === 'linked';\n  });\n\n  if (linkedColumns.length) {\n    assetsService.loadJs('lib/typeahead.js/typeahead.bundle.min.js').then(function () {\n      return $timeout(function () {\n        return linkedColumns.forEach(function (l) {\n          return _this.bindLinkedColumn(l);\n        });\n      });\n    });\n  } // specific to edit //\n\n\n  if (this.$scope.model.type === 'edit') {\n    this.hasGeocodedAddress = this.$scope.model.data._Address && this.$scope.model.data._Address.lat !== undefined && this.$scope.model.data._Address.lng !== undefined; // if the passed data includes an address, and the value changes\n    // set a flag to recode the address\n\n    this.addressWatch = this.$scope.$watch('model.data.Address', function (newVal, oldVal) {\n      if (newVal !== oldVal) {\n        _this.$scope.model.recode = true;\n      }\n    });\n  }\n};\n\nexports.TabulateDialogController = TabulateDialogController;\n\n_defineProperty(TabulateDialogController, \"name\", \"Tabulate.Dialog.Controller\");\n\n},{}],20:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TabulateMapDialogController = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TabulateMapDialogController = function TabulateMapDialogController($scope) {\n  _classCallCheck(this, TabulateMapDialogController);\n\n  var map = new google.maps.Map(document.getElementById('map'), {\n    zoom: 14,\n    center: new google.maps.LatLng($scope.model.lat, $scope.model.lng)\n  });\n  var marker = new google.maps.Marker({\n    map: map,\n    position: new google.maps.LatLng($scope.model.lat, $scope.model.lng),\n    draggable: true\n  });\n\n  var dragend = function dragend(e) {\n    if ($scope.model.lat !== e.latLng.lat() || $scope.model.lng !== e.latLng.lng()) {\n      $scope.model.lat = e.latLng.lat();\n      $scope.model.lng = e.latLng.lng();\n    }\n  };\n\n  google.maps.event.addListener(marker, 'dragend', function (event) {\n    dragend(event);\n  });\n};\n\nexports.TabulateMapDialogController = TabulateMapDialogController;\n\n_defineProperty(TabulateMapDialogController, \"name\", \"Tabulate.MapDialog.Controller\");\n\n},{}],21:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TabulateSettingsController = void 0;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TabulateSettingsController = function TabulateSettingsController($scope, $filter, tabulateResource, overlayService, editorState) {\n  var _this = this;\n\n  _classCallCheck(this, TabulateSettingsController);\n\n  _defineProperty(this, \"$onDestroy\", function () {\n    _this.watchImportExport();\n  });\n\n  _defineProperty(this, \"changedColumn\", function (columnIndex) {\n    _this.$scope.model.changes[columnIndex].newName = _this.$scope.model.config.columns[columnIndex].displayName;\n    _this.$scope.model.changes[columnIndex].newType = _this.$scope.model.config.columns[columnIndex].type;\n  });\n\n  _defineProperty(this, \"setTargetEditorColumns\", function (alias) {\n    if (!alias) return;\n\n    var target = _this.tabulateEditors.find(function (v) {\n      return v.alias === alias;\n    });\n\n    if (target) {\n      _this.targetEditorColumns = target.value.settings.columns;\n    }\n  });\n\n  _defineProperty(this, \"addEmptyItem\", function () {\n    if (!_this.$scope.model.config.mappings) {\n      _this.$scope.model.config.mappings = [];\n    }\n\n    _this.$scope.model.config.mappings.push({});\n  });\n\n  _defineProperty(this, \"removeMapping\", function (index) {\n    return _this.$scope.model.config.mappings.splice(index, 1);\n  });\n\n  _defineProperty(this, \"show\", function (type) {\n    _this.showing = type;\n    _this.importExport = _this.showing === 'json' ? _this.jsonSource : _this.csvSource;\n  });\n\n  _defineProperty(this, \"addColumn\", function () {\n    _this.$scope.model.config.columns.push({\n      displayName: _this.newColumnName,\n      type: _this.newColumnType\n    });\n\n    _this.newColumnName = null;\n    _this.newColumnType = null;\n  });\n\n  _defineProperty(this, \"removeColumn\", function (i) {\n    _this.overlayService.confirm({\n      confirmMessage: 'Are you sure you want to remove this column?',\n      hideHeader: true,\n      submit: function submit() {\n        _this.$scope.model.columnsToRemove.push(i); // data is removed on submit\n\n\n        _this.$scope.model.config.columns.splice(i); // remove it from the current columns list\n\n\n        _this.overlayService.close();\n      },\n      close: function close() {\n        return _this.overlayService.close();\n      }\n    });\n  });\n\n  _defineProperty(this, \"download\", function () {\n    var filename = \"download.\".concat(_this.showing);\n    var d = JSON.parse(JSON.stringify(_this.importExport)); // we need a copy of the data, not a reference\n\n    if (!navigator.userAgent.match(/msie|trident/i)) {\n      var saving = document.createElement('a');\n      saving.href = \"data:attachment/\".concat(_this.showing, \",\").concat(encodeURIComponent(d));\n      saving.download = filename;\n      saving.click();\n    } else {\n      var blob = new Blob([d]);\n      window.navigator.msSaveOrOpenBlob(blob, filename);\n    }\n  });\n\n  _defineProperty(this, \"convertCsvToJson\", function (csv) {\n    try {\n      var array = _this.tabulateResource.CSVtoArray(csv);\n\n      var objArray = [];\n      var key;\n\n      for (var i = 1; i < array.length; i += 1) {\n        objArray[i - 1] = {};\n\n        for (var j = 0; j < array[0].length && j < array[i].length; j += 1) {\n          key = array[0][j];\n\n          if (!_this.importKeys.includes(key)) {\n            _this.importKeys.push(key);\n          }\n\n          objArray[i - 1][key] = array[i][j];\n        }\n      }\n\n      var json = JSON.stringify(objArray);\n      return json.replace(/\\},/g, '},\\r\\n');\n    } catch (e) {\n      _this.setImportAlert('danger', 'Unable to convert CSV to JSON: ' + e);\n\n      return '';\n    }\n  });\n\n  _defineProperty(this, \"geocodeAddresses\", function (index, geoStr, p) {\n    var address = _this.$scope.model.data[index];\n\n    _this.geocoder.geocode({\n      'address': address[p]\n    }, function (results, status) {\n      /* if the geocoding was successful, add the location to the object, otherwise, set location as undefined to ensure key exists */\n      if (status === google.maps.GeocoderStatus.OK) {\n        address[geoStr] = results[0].geometry.location;\n      } else {\n        address[geoStr] = undefined;\n\n        _this.setImportAlert('danger', \"Geocoding failed for address: \".concat(address[p]));\n      }\n      /* recurse through the data object */\n\n\n      if (index + 1 < l) {\n        _this.geocodeAddresses(index + 1, geoStr, p);\n      }\n    });\n  });\n\n  _defineProperty(this, \"importCsv\", function () {\n    /* parse the csv and push into the data object, provided it is no longer than 250 records */\n    var csvToJson = JSON.parse(_this.convertCsvToJson(_this.importExport));\n\n    if (csvToJson.length > 0 && csvToJson.length < 2510) {\n      _this.$scope.model.data = csvToJson;\n      /* prompt for geocoding */\n\n      /* geocodeAddresses method recurses through the data model */\n\n      if (_this.importKeys.includes('Address')) {\n        /* accepts seed index, alias for encoded address, alias for source property */\n        if (window.google.maps) {\n          _this.geocoder = new google.maps.Geocoder();\n\n          _this.geocodeAddresses(0, '_Address', 'Address');\n        } else {\n          _this.setImportAlert('danger', 'Google maps API not available - geocoding failed');\n        }\n      }\n      /* clear the config array and update with the new keys from the csv */\n\n\n      _this.$scope.model.config.columns = [];\n\n      var _iterator = _createForOfIteratorHelper(_this.importKeys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n\n          _this.$scope.model.config.columns.push({\n            displayName: key,\n            type: 'string'\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      _this.afterImport();\n    } else {\n      _this.setImportAlert('danger', 'Import failed - dataset must be between 1 and 250 records');\n    }\n  });\n\n  _defineProperty(this, \"importJson\", function () {\n    try {\n      _this.$scope.model.data = JSON.parse(_this.importExport);\n\n      _this.afterImport();\n    } catch (e) {\n      _this.setImportAlert('danger', 'Import failed - unable to parse JSON input');\n    }\n  });\n\n  _defineProperty(this, \"import\", function () {\n    _this.importAlert = null;\n\n    if (_this.importExport.length) {\n      _this.overlayService.confirm({\n        confirmMessage: 'Importing will overwrite all existing data. Continue?',\n        hideHeader: true,\n        submit: function submit(_) {\n          if (_this.showing === 'json') {\n            _this.importJson();\n          } else {\n            _this.importCsv();\n          }\n\n          _this.overlayService.close();\n        },\n        close: function close() {\n          return _this.overlayService.close();\n        }\n      });\n    }\n  });\n\n  _defineProperty(this, \"afterImport\", function () {\n    /* disable importing, set a flag for config changes and new data */\n    _this.importDisabled = true;\n    _this.$scope.model.configChanged = true;\n\n    _this.setImportAlert('success', 'Import complete - submit to confirm');\n  });\n\n  _defineProperty(this, \"setImportAlert\", function (state, message) {\n    return _this.importAlert = {\n      state: state,\n      message: message\n    };\n  });\n\n  _defineProperty(this, \"sort\", function () {\n    if (_this.$scope.model.data && _this.$scope.model.config.sortOrder !== 'M') {\n      _this.$scope.model.data = _this.$filter('orderBy')(_this.$scope.model.data, '_label', _this.$scope.model.config.sortOrder === 'D');\n    }\n\n    _this.$scope.model.configChanged = true;\n  });\n\n  this.$scope = $scope;\n  this.$filter = $filter;\n  this.tabulateResource = tabulateResource;\n  this.overlayService = overlayService;\n  this.editorState = editorState;\n  this.importKeys = []; // array of header text from imported csv\n\n  this.geocoder;\n  this.types = tabulateResource.fieldTypes();\n  this.importDisabled = true;\n  this.importAlert = null;\n  this.showing = 'json';\n  this.$scope.model.columnsToRemove = []; // remove an existing column - need to handle data removal\n\n  this.$scope.model.changes = []; // store a copy of the config object for comparison when the modal is submitted\n  // for mapping\n\n  this.tabulateEditors = tabulateResource.getTabulateEditors(this.$scope.model.alias, this.editorState.current.variants.find(function (v) {\n    return v.active;\n  }));\n\n  if (this.$scope.model.config.columns && this.$scope.model.config.columns.length) {\n    for (var i = 0; i < this.$scope.model.config.columns.length; i += 1) {\n      /* set default sort order if none exists */\n      if (i === 0 && this.$scope.model.config.columns[i].sortOrder) {\n        this.$scope.model.config.columns[i].sortOrder = 'A';\n      }\n      /* push copy into changes object */\n\n\n      this.$scope.model.changes.push({\n        old: this.$scope.model.config.columns[i].displayName\n      });\n    } // set a default label to the display name of the first column\n\n\n    if (this.$scope.model.config.label === '') {\n      this.$scope.model.config.label = \"{\".concat(this.$scope.model.config.columns[0].displayName, \"}\");\n    }\n  }\n  /* by default, disable the import button, if there is data, display in the view */\n\n\n  if (this.$scope.model.data) {\n    this.jsonSource = JSON.stringify(this.$scope.model.data);\n    this.csvSource = this.tabulateResource.JSONtoCSV(this.$scope.model.data, this.$scope.model.config.columns);\n    this.show('json');\n  } // when the importExport value changes, only allow importing if that value\n  // is different to the original data for that type\n\n\n  this.watchImportExport = $scope.$watch(function () {\n    return _this.importExport;\n  }, function (newVal) {\n    _this.importDisabled = newVal === (_this.showing === 'json' ? _this.jsonSource : _this.csvSource);\n  });\n};\n\nexports.TabulateSettingsController = TabulateSettingsController;\n\n_defineProperty(TabulateSettingsController, \"name\", 'Tabulate.Settings.Controller');\n\n},{}],22:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResourcesModule = void 0;\n\nvar _tabulate = require(\"./tabulate.resource\");\n\nvar _tabulatePaging = require(\"./tabulate.paging.service\");\n\nvar ResourcesModule = angular.module('tabulate.resources', []).service(_tabulate.TabulateResource.name, _tabulate.TabulateResource).service(_tabulatePaging.TabulatePagingService.name, _tabulatePaging.TabulatePagingService).name;\nexports.ResourcesModule = ResourcesModule;\n\n},{\"./tabulate.paging.service\":23,\"./tabulate.resource\":24}],23:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TabulatePagingService = void 0;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TabulatePagingService = function TabulatePagingService() {\n  var _this = this;\n\n  _classCallCheck(this, TabulatePagingService);\n\n  _defineProperty(this, \"countPages\", function (total, perPage) {\n    return Math.ceil(parseInt(total, 10) / parseInt(perPage, 10));\n  });\n\n  _defineProperty(this, \"updatePaging\", function (items, filter, pageNumber, numPerPage) {\n    var begin = (pageNumber - 1) * numPerPage,\n        end = begin + numPerPage,\n        paged = items; // if a filter value exists, filter the items before paging\n\n    if (filter) {\n      paged = _this.getFilteredPage(items, filter);\n    }\n\n    var totalPages = Math.ceil(paged.length / numPerPage);\n\n    if (pageNumber > totalPages) {\n      begin = 0;\n      end = begin + totalPages;\n      pageNumber = 1;\n    }\n\n    return {\n      items: paged.slice(begin, end),\n      totalPages: totalPages,\n      pageNumber: pageNumber,\n      search: filter\n    };\n  });\n\n  _defineProperty(this, \"getFilteredPage\", function (items, term) {\n    var paged = [];\n    var l = items.length;\n    term = term.toString().toLowerCase();\n    var i, // loop index\n    j, // inner loop index\n    o, // the object plucked from items array\n    keys, pushed;\n\n    for (i = 0; i < l; i += 1) {\n      o = items[i];\n      pushed = false;\n\n      if (_typeof(o) === 'object') {\n        keys = Object.keys(o);\n\n        for (j = 0; j < keys.length; j++) {\n          if (!pushed && o[keys[j]] && o[keys[j]].toString().toLowerCase().includes(term)) {\n            paged.push(o);\n            pushed = true;\n          }\n        }\n      } else {\n        if (o && o.toLowerCase().includes(term)) {\n          paged.push(o);\n        }\n      }\n    }\n\n    return paged;\n  });\n\n  _defineProperty(this, \"setCurrentPage\", function (i, j) {\n    return j === undefined ? i - 1 > 0 ? i - 1 : i : i + 1 <= j ? i + 1 : i;\n  });\n}\n/**\r\n * \r\n * @param {any} total\r\n * @param {any} perPage\r\n */\n;\n\nexports.TabulatePagingService = TabulatePagingService;\n\n_defineProperty(TabulatePagingService, \"name\", 'tabulatePagingService');\n\n},{}],24:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TabulateResource = void 0;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TabulateResource = function TabulateResource(notificationsService, assetsService, $q, editorState) {\n  var _this = this;\n\n  _classCallCheck(this, TabulateResource);\n\n  _defineProperty(this, \"fieldTypes\", function () {\n    return [{\n      label: 'Text string',\n      value: 'string'\n    }, {\n      label: 'Textarea',\n      value: 'textarea'\n    }, {\n      label: 'Rich text',\n      value: 'rte'\n    }, {\n      label: 'Number',\n      value: 'number'\n    }, {\n      label: 'Email',\n      value: 'email'\n    }, {\n      label: 'Telephone',\n      value: 'tel'\n    }, {\n      label: 'Date',\n      value: 'date'\n    }, {\n      label: 'Url',\n      value: 'url'\n    }, {\n      label: 'Color',\n      value: 'color'\n    }, {\n      label: 'Linked',\n      value: 'linked'\n    }];\n  });\n\n  _defineProperty(this, \"JSONtoCSV\", function (json, header) {\n    var arr = _typeof(json) !== 'object' ? JSON.parse(json) : json;\n    var headerKeys = [];\n    var csv = '',\n        row,\n        i,\n        j,\n        o; //This condition will generate the Label/Header\n\n    if (header) {\n      row = ''; // iterate config as header, taking unique display names\n\n      for (i = 0; i < header.length; i += 1) {\n        var name = header[i].displayName;\n\n        if (headerKeys.indexOf(name) === -1) {\n          headerKeys.push(name);\n          row += name + ',';\n        }\n      } // trim trailing comma\n\n\n      row = row.slice(0, -1); //append Label row with line break\n\n      csv += row + '\\r\\n';\n    } //1st loop is to extract each row\n\n\n    for (i = 0; i < arr.length; i += 1) {\n      row = '';\n      o = arr[i];\n\n      for (j = 0; j < headerKeys.length; j += 1) {\n        var headerKey = o[headerKeys[j]];\n\n        if (headerKey !== undefined) {\n          var data = typeof headerKey === 'string' ? headerKey : JSON.stringify(headerKey);\n          row += \"\\\"\".concat(data.replace(/\"/gi, '\"\"'), \"\\\",\");\n        } else {\n          row += '\"\",';\n        }\n      } // trim trailling comma\n\n\n      row = row.slice(0, -1); //add a line break after each row\n\n      csv += row + '\\r\\n';\n    }\n\n    return csv;\n  });\n\n  _defineProperty(this, \"CSVtoArray\", function (strData, strDelimiter) {\n    strDelimiter = strDelimiter || ',';\n    var objPattern = new RegExp(\"(\\\\\".concat(strDelimiter, \"|\\\\r?\\\\n|\\\\r|^)(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|([^\\\"\\\\\").concat(strDelimiter, \"\\\\r\\\\n]*))\"), 'gi');\n    var arrData = [[]];\n    var arrMatches, strMatchedDelimiter, strMatchedValue;\n\n    while (arrMatches = objPattern.exec(strData)) {\n      strMatchedDelimiter = arrMatches[1];\n\n      if (strMatchedDelimiter.length && strMatchedDelimiter !== strDelimiter) {\n        // Since we have reached a new row of data,\n        // add an empty row to our data array.\n        arrData.push([]);\n      }\n\n      if (arrMatches[2]) {\n        strMatchedValue = arrMatches[2].replace(new RegExp('\"\"', 'g'), '\"');\n      } else {\n        strMatchedValue = arrMatches[3];\n      }\n\n      arrData[arrData.length - 1].push(strMatchedValue);\n    }\n\n    return arrData;\n  });\n\n  _defineProperty(this, \"loadGoogleMaps\", function (apiKey) {\n    var deferred = _this.$q.defer();\n\n    if (!apiKey) {\n      return deferred.resolve(false);\n    }\n\n    var loadMapsApi = function loadMapsApi() {\n      if (!window.google.maps) {\n        window.google.load('maps', '3', {\n          other_params: \"key=\".concat(apiKey),\n          callback: function callback() {\n            return deferred.resolve(true);\n          }\n        });\n      } else if (window.google.maps) {\n        deferred.resolve(true);\n      }\n    };\n\n    if (!window.google) {\n      _this.assetsService.loadJs('https://www.google.com/jsapi').then(function () {\n        return loadMapsApi();\n      });\n    } else {\n      loadMapsApi();\n    }\n\n    return deferred.promise;\n  });\n\n  _defineProperty(this, \"geocode\", function (d) {\n    if (!window.google.maps) return d;\n    var keys = Object.keys(d);\n    var p = keys.indexOf('Address') !== -1 ? 'Address' : '';\n\n    if (p !== '' && confirm('Found location data - geocode it?')) {\n      var geoStr = \"_\".concat(p);\n      var geocoder = new google.maps.Geocoder();\n      var address = d[p];\n      geocoder.geocode({\n        'address': address\n      }, function (results, status) {\n        if (status === google.maps.GeocoderStatus.OK) {\n          d[geoStr] = results[0].geometry.location;\n          d.lat = results[0].geometry.location.lat();\n          d.lng = results[0].geometry.location.lng();\n\n          _this.notificationsService.success('Success', 'Geocode successful');\n        } else {\n          d[geoStr] = undefined;\n\n          _this.notificationsService.error('Error', \"Geocode failed: \".concat(status));\n        }\n      });\n    }\n\n    return d;\n  });\n\n  _defineProperty(this, \"setLabels\", function (items, force, format) {\n    if (!items) return;\n\n    if (Array.isArray(items)) {\n      items.forEach(function (item) {\n        return parseLabel(item);\n      });\n    } else {\n      parseLabel(items);\n    } // construct the label for the item/s, based on the pattern defined in settings\n    // labels can refer to object properties - defined by parent|child in the label\n\n\n    function parseLabel(o) {\n      if (force || o._label === undefined) {\n        var pattern = /{(.*?)}/g;\n        var m;\n        var label = '';\n\n        do {\n          m = pattern.exec(format);\n\n          if (m) {\n            var labelKeys = m[1].split('|');\n            var replacementText = '';\n\n            if (labelKeys[0]) {\n              replacementText = labelKeys.length === 1 ? o[labelKeys[0]] : o[labelKeys[0]][labelKeys[1]];\n            }\n\n            label = label.length ? label.replace(m[0], replacementText) : format.replace(m[0], replacementText);\n          }\n        } while (m);\n\n        o._label = label;\n      }\n    }\n  });\n\n  _defineProperty(this, \"getTabulateEditors\", function (currentAlias, variant) {\n    // stores refs to other editors for mapping\n    var tabulateEditors = [];\n    /* set values for the mappings - can map to any other tabulate instance on the node */\n\n    variant.tabs.forEach(function (v) {\n      v.properties.forEach(function (vv) {\n        if (currentAlias !== vv.alias && vv.editor === 'NW.Tabulate') {\n          tabulateEditors.push(vv);\n        }\n      });\n    });\n    return tabulateEditors;\n  });\n\n  _defineProperty(this, \"updateMappedEditor\", function (source, previous, mappings, alias, variant) {\n    if (!mappings || !mappings.length) return;\n\n    var tabulateEditors = _this.getTabulateEditors(alias, variant);\n\n    mappings.forEach(function (m) {\n      var mappingElement = tabulateEditors.find(function (x) {\n        return x.alias === m.targetEditor.alias;\n      });\n      if (!mappingElement) return;\n      var updatedCount = 0;\n      var fromKey = m.sourceProperty.displayName;\n      var toKey = m.targetProperty.displayName; // if the mapped field is also defined as a linked property, use the toKey_label field\n      // since linked fields store the label\n\n      if (mappingElement.value.data[0].hasOwnProperty(toKey + '_link')) {\n        fromKey = '_label';\n      }\n\n      var rowsToUpdate = mappingElement.value.data.filter(function (d) {\n        return d[toKey] === previous[fromKey];\n      });\n      rowsToUpdate.forEach(function (row) {\n        row[toKey] = source[fromKey];\n        row.disabled = !!source.disabled;\n\n        _this.setLabels(row, true, mappingElement.value.settings.label);\n\n        updatedCount += 1;\n      });\n      if (updatedCount === 0) return;\n\n      _this.notificationsService.warning(\"\".concat(updatedCount, \" linked row\").concat(updatedCount > 1 ? 's' : '', \" modified in \").concat(m.targetEditor.label));\n    });\n  });\n\n  this.notificationsService = notificationsService;\n  this.assetsService = assetsService;\n  this.$q = $q;\n  this.editorState = editorState;\n};\n\nexports.TabulateResource = TabulateResource;\n\n_defineProperty(TabulateResource, \"name\", 'tabulateResource');\n\n},{}]},{},[16,18,19,20,21,17,23,24,22]);\n"],"file":"tabulate.js"}